Hacker Rank Balanced Brackets:
------------------------------

Create a dictionary for matching parentheses, i.e. brackets.
    The key is the closing bracket the value is the opening bracket.
Is balanced function parameter the string containing the brackets
    parentheses <- empty list, will be used as a stack
    Loop through each character of the string
        If the character is in the values of the matching parentheses dictionary
            append it to the stack
        else if the character is one of the keys
            if there are no characters on the stack
                return False
            if the last character on the stack does not match the expected character from the matching parentheses
                return False
            pop the last item from the stack
    if there are still characters on the stack
        return False
    return True

Hacker Rank Running Median:
---------------------------

This challenge makes use of a max and a min heap. The max heap will be used to hold the lower half of the
integers provided. Because it's a max heap, we use the heap from heapq and negate all of the values, the
first value will be the largest of the lower half of the provided values. The min heap will hold the upper
half of the provided integers such that the first value will be the smallest of the upper half. The heaps
will need to be kept balanced with no more than 1 extra value on each heap at any time.

add number function parameters: number to add, max heap, min heap
    if there is no max heap or number < -max heap[0]
        heap push the number onto the max heap
    else
        heap push the number onto the min heap

balance heaps function parameters: max heap, min heap
    if length of min heap - length of max heap >= 2
        heap push onto max heap the negative heap pop from min heap
    if length of max heap - length of min heap >= 2
        heap push onto min heap the negative heap pop from max heap

get median function parameters: max heap, min heap
    if length of heaps are equal
        return min heap[0] + max heap[0] / 2
    else if length of min heap > length of max heap
        return float of min heap[0]
    return float of negated max heap[0]

running median function parameter incoming array of integers
    results <- empty list
    max heap <- empty list
    min heap <- empty list
    loop through array of integers
        call add number with current number, max heap, min heap
        call balance heaps with max heap and min heap
        append to results return from call to get median with max heap and min heap
    return results

In Flight Movies:
-----------------

This challenge is about finding the movies that, when watched together, come closest to the length of
the flight minus 30 minutes.

add up all movies iterative function parameters: list of movie durations
    return set <- empty set
    loop from 0 to length of list of movie durations
        loop from outer loop index + 1 to length of list of movie durations
            add tuple duration at index outer loop + duration at index of inner loop
                duration at index of outer loop
                duration at index of inner loop
    return list of return set

add up all movies recursive function parameters: first index, list of movie durations, return list
    if a first index is larger then the list of movie durations
        return the return list provided
    loop index in range first index + 1 to length of list of movie durations
        append to return list tuple:
            duration at first index + duration at second index
            duration at first index
            duration at second index
    call add up all movies recursive with first index + 1, list of movie durations, return list

Leet Code Accounts Merge:
-------------------------

The input is a list of lists where element 0 in each list is a username and the remaining elements are
email addresses belonging to the user name. The goal is to combine all emails, even if the username may
be the same or different for multiple users. The idea is that the email is the determining factor.

Union Find Class:
    __init__ function parameters: self, number of expected vertices
        self ids <- list of values from 0 to number of expected vertices - 1

    find function parameters: Index for which to find the parent, i.e. the set to which this index belongs
        loop while index != self .ids[index]
            self .ids[index] <- self .ids[self .ids[index]]  # This is where path compression is implemented
            index <- self .ids[index]
        return index

    union function parameters: first index, second index
        first, second <- self .find(first), self .find(second)
        self .ids[first] <- self .ids[second]

merge accounts function parameters: list of list of accounts and emails
    email to name <- dict()
    loop over accounts
        name <- accounts at first index
        loop over account emails, i.e. account starting at second index to end of emails
            email to name [email] <- name

    Create list of unique IDs for each email
        email to ids <- dictionary with key set to email and value to unique index
        # e.g.: {email: index for index, email in enumerate(email_to_name.keys())}

    Create the union find with number set to length of the keys for email to ids
    Loop through accounts
        loop through emails for each account starting at index 2
            union find union account email at index 1 with email

    Create users <- defaultdict(list)
    Loop through email in email to name dictionary
        append email to users at ID from union find find(emails to ids[email])

    Create merge result <- empty list
    Loop through users dictionary values, i.e. emails
        append to merge result list of email to name [emails[0]] + sorted(emails)
    return merge result

Leet Code Add Two Numbers:
--------------------------

The input will be two linked lists each representing a non-negative number, with no leading zeroes except
the value 0 itself, in reverse order, i.e. 123 will be represented as: 3->2->1. Add the two number and
return them as a reverse order linked list.

class ListNode
    __init__ parameters: self, value, next <- None
        self .value = value
        self .next = next

    __str__ parameters: self
        current <- self
        output <- empty string, e.g. ""
        loop while current is not None
            if length of the output > 0
                output += "->"
            output += str(self .value)
            current <- current.next
        return output

    __eq__ parameters: self, other ListNode
        current1 <- self
        current2 <- other
        loop while current1 is not None
            if current1 .value != current2 .value
                return False
            current1 <- current1 .next
            current2 <- current2 .next
            if current2 is None
                if current 1 is not None
                    return False
        if current2 is not None
            return False
        return True

get number helper function parameters: ListNode
    number <- empty string, e.g. ""
    current <- ListNode
    loop while current is not None
        number += str(current .value)
        current <- current .next
    reverse the number string, e.g. number <- number[::-1]
    return int(number)

build list helper function parameters: numbers to convert to ListNode in an array
    current <- None
    return_ln <- None
    loop for each number in reversed numbers list
        if current is None
            current <- ListNode number
            return_ln <- current
        else
            ln <- ListNode  number
            current .next <- ln
            current <- current .next
    return return_ln

add two numbers function parameters: ListNode1, ListNode2
    number1 <- get number ListNode1
    number2 <- get number ListNode2
    total <- number1 + number2
    current = None
    loop through the reversed string of total, e.g. str(total)[::-1]
        if current is None
            current <- ListNode integer of current number
            return list node <- current # Set the return to be the first member of the linked list
        else
            list node <- ListNode integer of current number
            current .next <- list node
            current <- current .next
    return return list node

Leet Code Connect Ropes:
------------------------

This challenge is to connect all of the segments of ropes, lengths provided in array of lengths, together
two ropes at a time, using the smallest two ropes at each iteration. The cost for adding ropes is the sum
of their lengths. For example assume an array of ropes of the following lengths: [8, 4, 6, 12]
First add 4 and 6 for a cost of 10, the list of ropes would then be: [8, 10, 12]
Next add 8 and 10 together for a cost of 18, the list of ropes would then be: [18, 12]
Then connect the ropes of lengths 18 and 12 for a cost of 30
The total cost of connecting the ropes is: 10 + 18 + 30 or 58

In order to get the two shortest ropes in the best time, convert the incoming list of ropes to a minimum heap.

connect ropes cost function parameters: list of rope lengths
    total cost <- 0
    if length of list of ropes > 0:
        if length of list of ropes == 1
            return ropes [0]
        convert ropes into a heap
        loop while the length of the ropes is > 0
            if length of ropes > 1:
                first cost <- heappop ropes
                second cost <- heappop ropes
                total cost += first cost + second cost
                if we still have more ropes
                    heappush ropes first cost + second cost
            else
                total cost += heappop ropes
    return total cost

Leet Code Five Star Sellers:
----------------------------

The idea behind this challenge is a hypothetical situation where sellers who sell on Amazon need to reach
a certain threshold of 5 star ratings. If they are below the threshold, determine the number of 5 star
ratings they would need to get in order to reach the threshold.

The input is a list of lists of numbers where the first number is the current number of 5 star ratings
and the second number is the total of ratings. After the lists of ratings will be a float for the
threshold that this seller needs to reach. For example:

([[4,4], [1,2], [3,6]], 0.77)

Five Star Reviews function parameters: list of list of ratings, float threshold
    Copy the incoming list of ratings to a local variable, i.e.:
        product ratings <- deep copy of incoming list of ratings
    add five star count <- 0
    convert the ratings threshold to a percentage, i.e. multiply by 100 if it's < 1
    calculate the current percentage for this customer, i.e.:
        current percentage <- (sum([x[0] / x[1] for x in product_ratings]) / len(product_ratings)) * 100
    check if any product ratings are tuples, if so convert them to lists
    rating index <- 0
    loop while the current percentage is less than the threshold
        if rating index >= length of the product ratings
            rating index <- 0       # Start over from beginning, we cycle through the ratings adding
                                    # 5 star ratings where needed until we get to the threshold
        # The following is how we check if the current product rating is all 5 star ratings
        # In which case, skip this product rating
        if product rating [rating index][0] / product rating [rating index][1] >= 1
            rating index += 1
            continue
        # add a five start rating to this product's ratings
        product rating [rating index][0] += 1
        product rating [rating index][1] += 1
        add five star count += 1
        rating index += 1
        Calculate the current percentage, i.e.:
        current_percentage = (sum([x[0] / x[1] for x in product_ratings]) / len(product_ratings)) * 100
    return add five star count
