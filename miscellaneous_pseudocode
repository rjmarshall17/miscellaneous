Hacker Rank Balanced Brackets:
------------------------------

Create a dictionary for matching parentheses, i.e. brackets.
    The key is the closing bracket the value is the opening bracket.
Is balanced function parameter the string containing the brackets
    parentheses <- empty list, will be used as a stack
    Loop through each character of the string
        If the character is in the values of the matching parentheses dictionary
            append it to the stack
        else if the character is one of the keys
            if there are no characters on the stack
                return False
            if the last character on the stack does not match the expected character from the matching parentheses
                return False
            pop the last item from the stack
    if there are still characters on the stack
        return False
    return True

Hacker Rank Running Median:
---------------------------

This challenge makes use of a max and a min heap. The max heap will be used to hold the lower half of the
integers provided. Because it's a max heap, we use the heap from heapq and negate all of the values, the
first value will be the largest of the lower half of the provided values. The min heap will hold the upper
half of the provided integers such that the first value will be the smallest of the upper half. The heaps
will need to be kept balanced with no more than 1 extra value on each heap at any time.

add number function parameters: number to add, max heap, min heap
    if there is no max heap or number < -max heap[0]
        heap push the number onto the max heap
    else
        heap push the number onto the min heap

balance heaps function parameters: max heap, min heap
    if length of min heap - length of max heap >= 2
        heap push onto max heap the negative heap pop from min heap
    if length of max heap - length of min heap >= 2
        heap push onto min heap the negative heap pop from max heap

get median function parameters: max heap, min heap
    if length of heaps are equal
        return min heap[0] + max heap[0] / 2
    else if length of min heap > length of max heap
        return float of min heap[0]
    return float of negated max heap[0]

running median function parameter incoming array of integers
    results <- empty list
    max heap <- empty list
    min heap <- empty list
    loop through array of integers
        call add number with current number, max heap, min heap
        call balance heaps with max heap and min heap
        append to results return from call to get median with max heap and min heap
    return results

In Flight Movies:
-----------------

This challenge is about finding the movies that, when watched together, come closest to the length of
the flight minus 30 minutes.

add up all movies iterative function parameters: list of movie durations
    return set <- empty set
    loop from 0 to length of list of movie durations
        loop from outer loop index + 1 to length of list of movie durations
            add tuple duration at index outer loop + duration at index of inner loop
                duration at index of outer loop
                duration at index of inner loop
    return list of return set

add up all movies recursive function parameters: first index, list of movie durations, return list
    if a first index is larger then the list of movie durations
        return the return list provided
    loop index in range first index + 1 to length of list of movie durations
        append to return list tuple:
            duration at first index + duration at second index
            duration at first index
            duration at second index
    call add up all movies recursive with first index + 1, list of movie durations, return list

Leet Code Accounts Merge:
-------------------------

The input is a list of lists where element 0 in each list is a username and the remaining elements are
email addresses belonging to the user name. The goal is to combine all emails, even if the username may
be the same or different for multiple users. The idea is that the email is the determining factor.

Union Find Class:
    __init__ function parameters: self, number of expected vertices
        self ids <- list of values from 0 to number of expected vertices - 1

    find function parameters: Index for which to find the parent, i.e. the set to which this index belongs
        loop while index != self .ids[index]
            self .ids[index] <- self .ids[self .ids[index]]  # This is where path compression is implemented
            index <- self .ids[index]
        return index

    union function parameters: first index, second index
        first, second <- self .find(first), self .find(second)
        self .ids[first] <- self .ids[second]

merge accounts function parameters: list of list of accounts and emails
    email to name <- dict()
    loop over accounts
        name <- accounts at first index
        loop over account emails, i.e. account starting at second index to end of emails
            email to name [email] <- name

    Create list of unique IDs for each email
        email to ids <- dictionary with key set to email and value to unique index
        # e.g.: {email: index for index, email in enumerate(email_to_name.keys())}

    Create the union find with number set to length of the keys for email to ids
    Loop through accounts
        loop through emails for each account starting at index 2
            union find union account email at index 1 with email

    Create users <- defaultdict(list)
    Loop through email in email to name dictionary
        append email to users at ID from union find find(emails to ids[email])

    Create merge result <- empty list
    Loop through users dictionary values, i.e. emails
        append to merge result list of email to name [emails[0]] + sorted(emails)
    return merge result

Leet Code Add Two Numbers:
--------------------------

The input will be two linked lists each representing a non-negative number, with no leading zeroes except
the value 0 itself, in reverse order, i.e. 123 will be represented as: 3->2->1. Add the two number and
return them as a reverse order linked list.

class ListNode
    __init__ parameters: self, value, next <- None
        self .value = value
        self .next = next

    __str__ parameters: self
        current <- self
        output <- empty string, e.g. ""
        loop while current is not None
            if length of the output > 0
                output += "->"
            output += str(self .value)
            current <- current.next
        return output

    __eq__ parameters: self, other ListNode
        current1 <- self
        current2 <- other
        loop while current1 is not None
            if current1 .value != current2 .value
                return False
            current1 <- current1 .next
            current2 <- current2 .next
            if current2 is None
                if current 1 is not None
                    return False
        if current2 is not None
            return False
        return True

get number helper function parameters: ListNode
    number <- empty string, e.g. ""
    current <- ListNode
    loop while current is not None
        number += str(current .value)
        current <- current .next
    reverse the number string, e.g. number <- number[::-1]
    return int(number)

build list helper function parameters: numbers to convert to ListNode in an array
    current <- None
    return_ln <- None
    loop for each number in reversed numbers list
        if current is None
            current <- ListNode number
            return_ln <- current
        else
            ln <- ListNode  number
            current .next <- ln
            current <- current .next
    return return_ln

add two numbers function parameters: ListNode1, ListNode2
    number1 <- get number ListNode1
    number2 <- get number ListNode2
    total <- number1 + number2
    current = None
    loop through the reversed string of total, e.g. str(total)[::-1]
        if current is None
            current <- ListNode integer of current number
            return list node <- current # Set the return to be the first member of the linked list
        else
            list node <- ListNode integer of current number
            current .next <- list node
            current <- current .next
    return return list node

