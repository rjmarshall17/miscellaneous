Hacker Rank Balanced Brackets:
------------------------------
Create a dictionary for matching parentheses, i.e. brackets.
    The key is the closing bracket the value is the opening bracket.
Is balanced function parameter the string containing the brackets
    parentheses <- empty list, will be used as a stack
    Loop through each character of the string
        If the character is in the values of the matching parentheses dictionary
            append it to the stack
        else if the character is one of the keys
            if there are no characters on the stack
                return False
            if the last character on the stack does not match the expected character from the matching parentheses
                return False
            pop the last item from the stack
    if there are still characters on the stack
        return False
    return True

Hacker Rank Running Median:
---------------------------
This challenge makes use of a max and a min heap. The max heap will be used to hold the lower half of the
integers provided. Because it's a max heap, we use the heap from heapq and negate all of the values, the
first value will be the largest of the lower half of the provided values. The min heap will hold the upper
half of the provided integers such that the first value will be the smallest of the upper half. The heaps
will need to be kept balanced with no more than 1 extra value on each heap at any time.

add number function parameters: number to add, max heap, min heap
    if there is no max heap or number < -max heap[0]
        heap push the number onto the max heap
    else
        heap push the number onto the min heap

balance heaps function parameters: max heap, min heap
    if length of min heap - length of max heap >= 2
        heap push onto max heap the negative heap pop from min heap
    if length of max heap - length of min heap >= 2
        heap push onto min heap the negative heap pop from max heap

get median function parameters: max heap, min heap
    if length of heaps are equal
        return min heap[0] + max heap[0] / 2
    else if length of min heap > length of max heap
        return float of min heap[0]
    return float of negated max heap[0]

running median function parameter incoming array of integers
    results <- empty list
    max heap <- empty list
    min heap <- empty list
    loop through array of integers
        call add number with current number, max heap, min heap
        call balance heaps with max heap and min heap
        append to results return from call to get median with max heap and min heap
    return results

In Flight Movies:
-----------------
This challenge is about finding the movies that, when watched together, come closest to the length of
the flight minus 30 minutes.

add up all movies iterative function parameters: list of movie durations
    return set <- empty set
    loop from 0 to length of list of movie durations
        loop from outer loop index + 1 to length of list of movie durations
            add tuple duration at index outer loop + duration at index of inner loop
                duration at index of outer loop
                duration at index of inner loop
    return list of return set

add up all movies recursive function parameters: first index, list of movie durations, return list
    if a first index is larger then the list of movie durations
        return the return list provided
    loop index in range first index + 1 to length of list of movie durations
        append to return list tuple:
            duration at first index + duration at second index
            duration at first index
            duration at second index
    call add up all movies recursive with first index + 1, list of movie durations, return list

Leet Code Accounts Merge:
-------------------------
The input is a list of lists where element 0 in each list is a username and the remaining elements are
email addresses belonging to the user name. The goal is to combine all emails, even if the username may
be the same or different for multiple users. The idea is that the email is the determining factor.

Union Find Class:
    __init__ function parameters: self, number of expected vertices
        self ids <- list of values from 0 to number of expected vertices - 1

    find function parameters: Index for which to find the parent, i.e. the set to which this index belongs
        loop while index != self .ids[index]
            self .ids[index] <- self .ids[self .ids[index]]  # This is where path compression is implemented
            index <- self .ids[index]
        return index

    union function parameters: first index, second index
        first, second <- self .find(first), self .find(second)
        self .ids[first] <- self .ids[second]

merge accounts function parameters: list of list of accounts and emails
    email to name <- dict()
    loop over accounts
        name <- accounts at first index
        loop over account emails, i.e. account starting at second index to end of emails
            email to name [email] <- name

    Create list of unique IDs for each email
        email to ids <- dictionary with key set to email and value to unique index
        # e.g.: {email: index for index, email in enumerate(email_to_name.keys())}

    Create the union find with number set to length of the keys for email to ids
    Loop through accounts
        loop through emails for each account starting at index 2
            union find union account email at index 1 with email

    Create users <- defaultdict(list)
    Loop through email in email to name dictionary
        append email to users at ID from union find find(emails to ids[email])

    Create merge result <- empty list
    Loop through users dictionary values, i.e. emails
        append to merge result list of email to name [emails[0]] + sorted(emails)
    return merge result

Leet Code Add Two Numbers:
--------------------------
The input will be two linked lists each representing a non-negative number, with no leading zeroes except
the value 0 itself, in reverse order, i.e. 123 will be represented as: 3->2->1. Add the two number and
return them as a reverse order linked list.

class ListNode
    __init__ parameters: self, value, next <- None
        self .value = value
        self .next = next

    __str__ parameters: self
        current <- self
        output <- empty string, e.g. ""
        loop while current is not None
            if length of the output > 0
                output += "->"
            output += str(self .value)
            current <- current.next
        return output

    __eq__ parameters: self, other ListNode
        current1 <- self
        current2 <- other
        loop while current1 is not None
            if current1 .value != current2 .value
                return False
            current1 <- current1 .next
            current2 <- current2 .next
            if current2 is None
                if current 1 is not None
                    return False
        if current2 is not None
            return False
        return True

get number helper function parameters: ListNode
    number <- empty string, e.g. ""
    current <- ListNode
    loop while current is not None
        number += str(current .value)
        current <- current .next
    reverse the number string, e.g. number <- number[::-1]
    return int(number)

build list helper function parameters: numbers to convert to ListNode in an array
    current <- None
    return_ln <- None
    loop for each number in reversed numbers list
        if current is None
            current <- ListNode number
            return_ln <- current
        else
            ln <- ListNode  number
            current .next <- ln
            current <- current .next
    return return_ln

add two numbers function parameters: ListNode1, ListNode2
    number1 <- get number ListNode1
    number2 <- get number ListNode2
    total <- number1 + number2
    current = None
    loop through the reversed string of total, e.g. str(total)[::-1]
        if current is None
            current <- ListNode integer of current number
            return list node <- current # Set the return to be the first member of the linked list
        else
            list node <- ListNode integer of current number
            current .next <- list node
            current <- current .next
    return return list node

Leet Code Connect Ropes:
------------------------
This challenge is to connect all of the segments of ropes, lengths provided in array of lengths, together
two ropes at a time, using the smallest two ropes at each iteration. The cost for adding ropes is the sum
of their lengths. For example assume an array of ropes of the following lengths: [8, 4, 6, 12]
First add 4 and 6 for a cost of 10, the list of ropes would then be: [8, 10, 12]
Next add 8 and 10 together for a cost of 18, the list of ropes would then be: [18, 12]
Then connect the ropes of lengths 18 and 12 for a cost of 30
The total cost of connecting the ropes is: 10 + 18 + 30 or 58

In order to get the two shortest ropes in the best time, convert the incoming list of ropes to a minimum heap.

connect ropes cost function parameters: list of rope lengths
    total cost <- 0
    if length of list of ropes > 0:
        if length of list of ropes == 1
            return ropes [0]
        convert ropes into a heap
        loop while the length of the ropes is > 0
            if length of ropes > 1:
                first cost <- heappop ropes
                second cost <- heappop ropes
                total cost += first cost + second cost
                if we still have more ropes
                    heappush ropes first cost + second cost
            else
                total cost += heappop ropes
    return total cost

Leet Code Five Star Sellers:
----------------------------
The idea behind this challenge is a hypothetical situation where sellers who sell on Amazon need to reach
a certain threshold of 5 star ratings. If they are below the threshold, determine the number of 5 star
ratings they would need to get in order to reach the threshold.

The input is a list of lists of numbers where the first number is the current number of 5 star ratings
and the second number is the total of ratings. After the lists of ratings will be a float for the
threshold that this seller needs to reach. For example:

([[4,4], [1,2], [3,6]], 0.77)

Five Star Reviews function parameters: list of list of ratings, float threshold
    Copy the incoming list of ratings to a local variable, i.e.:
        product ratings <- deep copy of incoming list of ratings
    add five star count <- 0
    convert the ratings threshold to a percentage, i.e. multiply by 100 if it's < 1
    calculate the current percentage for this customer, i.e.:
        current percentage <- (sum([x[0] / x[1] for x in product_ratings]) / len(product_ratings)) * 100
    check if any product ratings are tuples, if so convert them to lists
    rating index <- 0
    loop while the current percentage is less than the threshold
        if rating index >= length of the product ratings
            rating index <- 0       # Start over from beginning, we cycle through the ratings adding
                                    # 5 star ratings where needed until we get to the threshold
        # The following is how we check if the current product rating is all 5 star ratings
        # In which case, skip this product rating
        if product rating [rating index][0] / product rating [rating index][1] >= 1
            rating index += 1
            continue
        # add a five start rating to this product's ratings
        product rating [rating index][0] += 1
        product rating [rating index][1] += 1
        add five star count += 1
        rating index += 1
        Calculate the current percentage, i.e.:
        current_percentage = (sum([x[0] / x[1] for x in product_ratings]) / len(product_ratings)) * 100
    return add five star count

Leet Code Fresh Promotion:
--------------------------
This challenge is about a secret promotion being run that, if the customer purchases items in the
promotion, they win a prize. There is a wildcard in the secret items, the string "anything".

fresh promotion check function parameters: list of list of strings for promotion, list for shopping cart
    shopping cart index <- 0
    loop through secret promotions list setting sublist to the next combination of products
        if shopping cart index >= length of shopping cart
            return LOSER (0)
        match found <- False
        wildcard indices <- empty list
        if wildcards are in the sublist
            loop through the sublist
                if the code sublist at index is a wildcard
                    append index to wildcard indices
        loop while shopping cart index < length of the shopping cart
            for wildcard index in wildcard indices
                modify the sublist to replace the wildcard index with whatever is in the shopping cart at that index:
                code_sublist[wildcard_index] = \
                    shopping_cart[shopping_cart_index:shopping_cart_index + len(code_sublist)][wildcard_index]
            if sublist == shopping cart starting at shopping cart index for length of sublist
                match found <- True
                exit while loop, i.e. break
            shopping cart index += 1
        if match found is False
            return LOSER (0)
        shopping cart index <- shopping cart index + length of matched sublist
    return WINNER (1)

Leet Code Items in Container:
-----------------------------
This challenge involves counting the number of items, each '*' character, that is in a container, i.e. between
two '|' characters.

count items helper function parameters: the items string
    count <- 0
    total count <- 0
    add item <- False
    for character in items string
        if character == '|'
            if add item is False
                add item <- True
            total count += count
            count <- 0
            continue
        if character == '*' and add item is True
            count += 1
    return total count

number of items function parameters: compartment string, start indices list, end indices list
    if length of start indices != length of end indices
        raise ValueError
    counts <- empty list
    if there is a compartment string
        for index in range of the length of the start indices
            append output from count items to counts, i.e.:
                counts.append(count_items(compartment_string[start_indices[i] - 1:end_indices[i]]))
    return counts list

Alternate method using rfind:
count items rfind helper function parameters: the items string
    return the count of items, each '*', between the first and last '|', i.e.:
        return items_string[items_string.find('|'):items_string.rfind('|')].count('*')

number of items rfind function parameters: compartment string, start indices list, end indices list
    if length of start indices != length of the end indices
        raise ValueError
    counts <- empty list
    if there is a compartment string
        for index in range of the length of the start indices
            append output from count items rfind helper to counts, i.e.
                counts.append(rfind_count_items(compartment_string[start_indices[i] - 1:end_indices[i]]))
    return counts

Leet Code Largest Item Association:
-----------------------------------
The idea of this challenge is that certain items are usually purchased together with other items. The
input to the function is a list of lists of items that area associated with each other. Each list of
items is a pair of items. The goal is to find the largest item association from the provided associations.
Return a list of strings representing the largest item association group, sorted lexicographically.

For example:

Input:
    itemAssociation
    [[item1, item2],
    [item3, item4],
    [item4, item5]]

Output:
    [item3, item4, item5]

Explanation:
    There are two item association groups:
    group1: [item1, item2]
    group2: [item3, item4, item5]
    In the available item associations, group2 has the largest association.
    So the output is: [item3, item4, item5]


largest item association function parameters: associations list of list of string
    item map <- default dictionary of set
    for item pair in associations
        item map [item pair[0]] add item pair[1]
        item map [item pair[1]] add item pair[0]
    largest group <- empty list
    visited <- set - could also just be a list
    loop through the item map with keys and values
        if key not in visited
            current group <- empty list
            queue <- deque
            append key to queue
            while there are still keys in the queue
                current <- queue popleft
                add key to visited
                append current to current group
                loop through each neighbor in the item map for current
                    if neighbor is not in visited
                        append neighbor to queue
            if current group length is > current largest group length
                largest group <- current group
    return sorted largest group

An alternative way to do this is with a union find. In this case the UnionFind has a most_members property
that determines which parent has the most members. The current implementation is:

    @property
    def most_members(self):
        """
        This function will return the parent with the most members.
        """
        most_members = -1
        for parent in set(self.union_find):
            if most_members < 0:
                most_members = parent
            if self.union_find.count(parent) > self.union_find.count(most_members):
                most_members = parent
        return most_members

largest item association function parameters: associations list of list of string
    sort and flatten the incoming associations, i.e.:
        sorted_items = sorted(set([item for sublist in associations for item in sublist]))
    create a map of items to a unique ID, i.e.:
        items_to_id = {sorted_items[index]: index for index in range(len(sorted_items))}
    uf <- UnionFind(length of sorted items)
    for items in associations
        uf .union items[0] items[1]
    return list <- empty list
    most members <- uf .most_members   # Returns the ID of the parent with the most members
    for item in sorted items
        if uf .find item by ID == most members
            append item to return list
    return the return list

Leet Code Longest Non-repeating String:
---------------------------------------
Given a string s, find the length of the longest substring without repeating characters.

Example 1:

Input: s = "abcabcbb"
Output: 3

Explanation: The answer is "abc", with the length of 3.

length of longest substring function parameters: string to check
    if length of string to check is 0
        return 0
    start index <- 0
    last seen <- empty dictionary
    longest <- [0,1]    # The start and end indices of the longest non-repeating string
    for string index, current character in enumerated string to check
        if current character in last seen
            start index <- maximum of start index or last seen [current character] + 1
        if longest[1] - longest[0] < string index + 1 - start index
            longest <- [start index, string index + 1]
        last seen [current character] <- string index
    return longest[1] - longest[0]

Leet Code Longest Palindromic String:
-------------------------------------
Given a string s, return the longest palindromic substring in s.

Example 1:

Input: s = "babad"
Output: "bab"

Note: "aba" is also a valid answer.

Assumptions: There are no spaces in the string, it is only characters a-z0-9 and that they are in lower case.

There are multiple ways to solve this challenge. The brute force solution has a time complexity of O(n**3). The
version that uses a left and right pointer is O(n**2). There is also the Manacher algorithm which is linear time,
i.e. O(n).

brute force function parameters: string to check
    if length of string to check <= 2
        return string to check index 0
    if string to check == string to check reversed, i.e. [::-1]
        return string to check
    bf longest palindrome <- ''
    for index in length of string to check
        for index2 in index + 1 to length of string to check
            if string to check [index:index2] == string to check [index:index2][::-1]
                if index2 - index > length of bf longest palindrome
                    bf longest palindrome <- string to check [index:index2]
    return bf longest palindrome

================
pointers version

get longest palindrome from helper function parameters: string to check, left index, right index
    loop while left index >= 0 and right index < length of the string to check
        if string to check [left index] != string to check [right index]
            exit loop, break
        left index -= 1
        right index += 1
    return left index + 1, right index

longest palindrome function parameters: string to check
    if the length of the string to check is <= 2
        return the first character of the string to check
    if string to check is a palindrome
        return string to check
    current longest <- [0,1]
    for index in range 1 to length of string to check
        odd <- call get longest palindrome from with index - 1, index + 1
        even <- call get longest palindrome from with index - 1, index
        longest <- max of odd even, i.e.:
             longest = max(odd, even, key=lambda x: x[1] - x[0])
        current longest <- max of longest and current longest, i.e.:
            current_longest = max(longest, current_longest, key=lambda x: x[1] - x[0])
    return string to check [current longest [0] : current longest [1]]

====================
Manacher's algorithm

The advantage of Manacher's algorithm is that it can find the longest palindrome in linear, i.e. O(n)
time.

manacher palindromes function parameters: string to check
    if length of string to check <= 2
        return the first character of the string to check
    if string to check is already a palindrome
        return string to check
    delimiter <- '#' - i.e. some character that is NOT in the string we are checking
    new string <- delimiter + delimiter.join(string to check) + delimiter
    new string length <- length of new string
    palindrome lengths <- [0] * new string length
    center <- 0
    right <- 0
    for index in range new string length
        mirror <- 2 * center + 1
        if index < right
            palindrome lengths [index] <- minimum of right - 1 or palindrome lengths [mirror]
        loop while index + 1 + palindrome lengths [index] < new string length and
            new string [index + (1 + palindrome lengths [index])] ==
            new string [index + (1 - palindrome lengths [index])]
            palindrome lengths [index] += 1
        if index + palindrome lengths [index] > right
            center <- index
            right <- 1 + palindrome lengths [index]
    longest <- max palindrome lengths
    center <- palindrome lengths .index(longest) // 2
    half word <- longest // 2
    start <- center - half word
    end <- center + half word
    add 0 to end if the longest % 2 == 0 else add 1
    return string to check [start:end]

Leet Code Median of Sorted Arrays:
----------------------------------
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median
of the two sorted arrays.

Follow up: The overall run time complexity should be O(log (m+n)).

Example 1:

Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000

Explanation: merged array = [1,2,3] and median is 2.

median of arrays function parameters: array one, array two
    # The time complexity for the sort of the two arrays is: O(NlogN)
    both arrays <- sorted(array one + array two)
    if length of both arrays == 1
        return both arrays [0]
    if length of both arrays % 2 == 0   # i.e. the length is an even number
        if length of both arrays == 2
            return sum of both arrays divided by 2, i.e.:
                return sum(both arrays)/2
        index = length of both arrays - 1 // 2
        return both arrays [index] + both arrays [index + 1] / 2
    return both arrays [length of both arrays // 2]     # i.e. the length is odd, return the middle value





