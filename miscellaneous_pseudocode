Hacker Rank Balanced Brackets:
------------------------------
Create a dictionary for matching parentheses, i.e. brackets.
    The key is the closing bracket the value is the opening bracket.
Is balanced function parameter the string containing the brackets
    parentheses <- empty list, will be used as a stack
    Loop through each character of the string
        If the character is in the values of the matching parentheses dictionary
            append it to the stack
        else if the character is one of the keys
            if there are no characters on the stack
                return False
            if the last character on the stack does not match the expected character from the matching parentheses
                return False
            pop the last item from the stack
    if there are still characters on the stack
        return False
    return True

Hacker Rank Running Median:
---------------------------
This challenge makes use of a max and a min heap. The max heap will be used to hold the lower half of the
integers provided. Because it's a max heap, we use the heap from heapq and negate all of the values, the
first value will be the largest of the lower half of the provided values. The min heap will hold the upper
half of the provided integers such that the first value will be the smallest of the upper half. The heaps
will need to be kept balanced with no more than 1 extra value on each heap at any time.

add number function parameters: number to add, max heap, min heap
    if there is no max heap or number < -max heap[0]
        heap push the number onto the max heap
    else
        heap push the number onto the min heap

balance heaps function parameters: max heap, min heap
    if length of min heap - length of max heap >= 2
        heap push onto max heap the negative heap pop from min heap
    if length of max heap - length of min heap >= 2
        heap push onto min heap the negative heap pop from max heap

get median function parameters: max heap, min heap
    if length of heaps are equal
        return min heap[0] + negated max heap[0] / 2
    else if length of min heap > length of max heap
        return float of min heap[0]
    return float of negated max heap[0]

running median function parameter incoming array of integers
    results <- empty list
    max heap <- empty list
    min heap <- empty list
    loop through array of integers
        call add number with current number, max heap, min heap
        call balance heaps with max heap and min heap
        append to results return from call to get median with max heap and min heap
    return results

Hacker Rank Running Median Class:
---------------------------------
Create a running median class for handling the running median challenge. The max heap uses negative values
in order to allow what is a min heap to function as a max heap. Here were are using heappush and heappop
from heapq.

class Running Median
    __init__ method parameters: self
        self.min_heap <- empty list
        self.max_head <- empty list

    add number method parameters: self, number to add
        if self.max_heap is empty or number < -max_heap[0]
            heappush number onto max heap
        else
            heappush number onto min heap
        call self.__balance_heaps__

    __balance_heaps__ method parameters: self
        if length of min heap - length of max heap >= 2
            heappush onto max heap negated value from heappop min heap
        if length of max heap - length of the min heap >= 2
            heappush onto min heap negated value from heappop max heap

    median method parameters: self
        if length of min heap == length of max heap
            # Because the max heap has negative values, subtracting is actually adding
            return min heap[0] - max heap[0] / 2
        else if length of min heap > length of max heap
            return float of min heap[0]
        return float of -max heap[0]

In Flight Movies:
-----------------
This challenge is about finding the movies that, when watched together, come closest to the length of
the flight minus 30 minutes.

add up all movies iterative function parameters: list of movie durations
    return set <- empty set
    loop from 0 to length of list of movie durations
        loop from outer loop index + 1 to length of list of movie durations
            add tuple duration at index outer loop + duration at index of inner loop
                duration at index of outer loop
                duration at index of inner loop
    return list of return set

add up all movies recursive function parameters: first index, list of movie durations, return list
    if a first index is larger then the list of movie durations
        return the return list provided
    loop index in range first index + 1 to length of list of movie durations
        append to return list tuple:
            duration at first index + duration at second index
            duration at first index
            duration at second index
    call add up all movies recursive with first index + 1, list of movie durations, return list

main function
    get list of all movies and durations, either iterative or recursive, list format:
        0 - addition of durations
        1 - first movie duration
        2 - second movie duration

    for movie times in sorted all movie durations, i.e.:
            for movie_times in sorted(all_movies_durations, key=lambda x: x[0])
        if movie times [0] > flight duration - 30
            print best movie previous[1], previous[2], previous[0]
        previous = movie times

Leet Code Accounts Merge:
-------------------------
The input is a list of lists where element 0 in each list is a username and the remaining elements are
email addresses belonging to the user name. The goal is to combine all emails, even if the username may
be the same or different for multiple users. The idea is that the email is the determining factor.

Union Find Class:
    __init__ function parameters: self, number of expected vertices
        self ids <- list of values from 0 to number of expected vertices - 1

    find function parameters: Index for which to find the parent, i.e. the set to which this index belongs
        loop while index != self .ids[index]
            self .ids[index] <- self .ids[self .ids[index]]  # This is where path compression is implemented
            index <- self .ids[index]
        return index

    union function parameters: first index, second index
        first, second <- self .find(first), self .find(second)
        self .ids[first] <- self .ids[second]

merge accounts function parameters: list of list of accounts and emails
    email to name <- dict()
    loop over accounts
        name <- accounts at first index
        loop over account emails, i.e. account starting at second index to end of emails
            email to name [email] <- name

    Create list of unique IDs for each email
        email to ids <- dictionary with key set to email and value to unique index
        # e.g.: {email: index for index, email in enumerate(email_to_name.keys())}

    Create the union find with number set to length of the keys for email to ids
    Loop through accounts
        loop through emails for each account starting at index 2
            union find union account email at index 1 with email

    Create users <- defaultdict(list)
    Loop through email in email to name dictionary
        append email to users at ID from union find find(emails to ids[email])

    Create merge result <- empty list
    Loop through users dictionary values, i.e. emails
        append to merge result list of email to name [emails[0]] + sorted(emails)
    return merge result

Leet Code Add Two Numbers:
--------------------------
The input will be two linked lists each representing a non-negative number, with no leading zeroes except
the value 0 itself, in reverse order, i.e. 123 will be represented as: 3->2->1. Add the two number and
return them as a reverse order linked list.

class ListNode
    __init__ parameters: self, value, next <- None
        self .value = value
        self .next = next

    __str__ parameters: self
        current <- self
        output <- empty string, e.g. ""
        loop while current is not None
            if length of the output > 0
                output += "->"
            output += str(self .value)
            current <- current.next
        return output

    __eq__ parameters: self, other ListNode
        current1 <- self
        current2 <- other
        loop while current1 is not None
            if current1 .value != current2 .value
                return False
            current1 <- current1 .next
            current2 <- current2 .next
            if current2 is None
                if current 1 is not None
                    return False
        if current2 is not None
            return False
        return True

get number helper function parameters: ListNode
    number <- empty string, e.g. ""
    current <- ListNode
    loop while current is not None
        number += str(current .value)
        current <- current .next
    reverse the number string, e.g. number <- number[::-1]
    return int(number)

build list helper function parameters: numbers to convert to ListNode in an array
    current <- None
    return_ln <- None
    loop for each number in reversed numbers list
        if current is None
            current <- ListNode number
            return_ln <- current
        else
            ln <- ListNode  number
            current .next <- ln
            current <- current .next
    return return_ln

add two numbers function parameters: ListNode1, ListNode2
    number1 <- get number ListNode1
    number2 <- get number ListNode2
    total <- number1 + number2
    current = None
    return result from build list called with array of integers from total

Leet Code Connect Ropes:
------------------------
This challenge is to connect all of the segments of ropes, lengths provided in array of lengths, together
two ropes at a time, using the smallest two ropes at each iteration. The cost for adding ropes is the sum
of their lengths. For example assume an array of ropes of the following lengths: [8, 4, 6, 12]
First add 4 and 6 for a cost of 10, the list of ropes would then be: [8, 10, 12]
Next add 8 and 10 together for a cost of 18, the list of ropes would then be: [18, 12]
Then connect the ropes of lengths 18 and 12 for a cost of 30
The total cost of connecting the ropes is: 10 + 18 + 30 or 58

In order to get the two shortest ropes in the best time, convert the incoming list of ropes to a minimum heap.

connect ropes cost function parameters: list of rope lengths
    total cost <- 0
    if length of list of ropes > 0:
        if length of list of ropes == 1
            return ropes [0]
        convert ropes into a heap
        loop while the length of the ropes is > 0
            if length of ropes > 1:
                first cost <- heappop ropes
                second cost <- heappop ropes
                total cost += first cost + second cost
                if we still have more ropes
                    heappush ropes first cost + second cost
            else
                total cost += heappop ropes
    return total cost

Leet Code Five Star Sellers:
----------------------------
The idea behind this challenge is a hypothetical situation where sellers who sell on Amazon need to reach
a certain threshold of 5 star ratings. If they are below the threshold, determine the number of 5 star
ratings they would need to get in order to reach the threshold.

The input is a list of lists of numbers where the first number is the current number of 5 star ratings
and the second number is the total of ratings. After the lists of ratings will be a float for the
threshold that this seller needs to reach. For example:

([[4,4], [1,2], [3,6]], 0.77)

Five Star Reviews function parameters: list of list of ratings, float threshold
    Copy the incoming list of ratings to a local variable, i.e.:
        product ratings <- deep copy of incoming list of ratings
    add five star count <- 0
    convert the ratings threshold to a percentage, i.e. multiply by 100 if it's < 1
    calculate the current percentage for this customer, i.e.:
        current percentage <- (sum([x[0] / x[1] for x in product_ratings]) / len(product_ratings)) * 100
    check if any product ratings are tuples, if so convert them to lists
    rating index <- 0
    loop while the current percentage is less than the threshold
        if rating index >= length of the product ratings
            rating index <- 0       # Start over from beginning, we cycle through the ratings adding
                                    # 5 star ratings where needed until we get to the threshold
        # The following is how we check if the current product rating is all 5 star ratings
        # In which case, skip this product rating
        if product rating [rating index][0] / product rating [rating index][1] >= 1
            rating index += 1
            continue
        # add a five start rating to this product's ratings
        product rating [rating index][0] += 1
        product rating [rating index][1] += 1
        add five star count += 1
        rating index += 1
        Calculate the current percentage, i.e.:
        current_percentage = (sum([x[0] / x[1] for x in product_ratings]) / len(product_ratings)) * 100
    return add five star count

Leet Code Fresh Promotion:
--------------------------
This challenge is about a secret promotion being run that, if the customer purchases items in the
promotion, they win a prize. There is a wildcard in the secret items, the string "anything".

fresh promotion check function parameters: list of list of strings for promotion, list for shopping cart
    shopping cart index <- 0
    loop through secret promotions list setting sublist to the next combination of products
        if shopping cart index >= length of shopping cart
            return LOSER (0)
        match found <- False
        wildcard indices <- empty list
        if wildcards are in the sublist
            loop through the sublist
                if the code sublist at index is a wildcard
                    append index to wildcard indices
        loop while shopping cart index < length of the shopping cart
            for wildcard index in wildcard indices
                modify the sublist to replace the wildcard index with whatever is in the shopping cart at that index:
                code_sublist[wildcard_index] = \
                    shopping_cart[shopping_cart_index:shopping_cart_index + len(code_sublist)][wildcard_index]
            if sublist == shopping cart starting at shopping cart index for length of sublist
                match found <- True
                exit while loop, i.e. break
            shopping cart index += 1
        if match found is False
            return LOSER (0)
        shopping cart index <- shopping cart index + length of matched sublist
    return WINNER (1)

Leet Code Items in Container:
-----------------------------
This challenge involves counting the number of items, each '*' character, that is in a container, i.e. between
two '|' characters.

count items helper function parameters: the items string
    count <- 0
    total count <- 0
    add item <- False
    if count of compartment characters >= 2
        for character in items string
            if character == '|'
                if add item is False
                    add item <- True
                total count += count
                count <- 0
                continue
            if character == '*' and add item is True
                count += 1
    return total count

number of items function parameters: compartment string, start indices list, end indices list
    if length of start indices != length of end indices
        raise ValueError
    counts <- empty list
    if the number of compartment characters >= 2
        for index in range of the length of the start indices
            append output from count items to counts, i.e.:
                counts.append(count_items(compartment_string[start_indices[i] - 1:end_indices[i]]))
    return counts list

Alternate method using rfind:
count items rfind helper function parameters: the items string
    if count of compartment characters < 2:
        return 0
    return the count of items, each '*', between the first and last '|', i.e.:
        return items_string[items_string.find('|'):items_string.rfind('|')].count('*')

number of items rfind function parameters: compartment string, start indices list, end indices list
    if length of start indices != length of the end indices
        raise ValueError
    counts <- empty list
    if there are two or more compartment characters in the string
        for index in range of the length of the start indices
            append output from count items rfind helper to counts, i.e.
                counts.append(rfind_count_items(compartment_string[start_indices[i] - 1:end_indices[i]]))
    return counts

Leet Code Largest Item Association:
-----------------------------------
The idea of this challenge is that certain items are usually purchased together with other items. The
input to the function is a list of lists of items that area associated with each other. Each list of
items is a pair of items. The goal is to find the largest item association from the provided associations.
Return a list of strings representing the largest item association group, sorted lexicographically.

For example:

Input:
    itemAssociation
    [[item1, item2],
    [item3, item4],
    [item4, item5]]

Output:
    [item3, item4, item5]

Explanation:
    There are two item association groups:
    group1: [item1, item2]
    group2: [item3, item4, item5]
    In the available item associations, group2 has the largest association.
    So the output is: [item3, item4, item5]

largest item association function parameters: associations list of list of string
    item map <- default dictionary of set
    for item pair in associations
        item map [item pair[0]] add item pair[1]
        item map [item pair[1]] add item pair[0]
    largest group <- empty list
    visited <- set - could also just be a list
    loop through the item map with keys and values
        if key not in visited
            current group <- empty list
            queue <- deque
            append key to queue
            while there are still keys in the queue
                current <- queue popleft
                add key to visited
                append current to current group
                loop through each neighbor in the item map for current
                    if neighbor is not in visited
                        append neighbor to queue
            if current group length is > current largest group length
                largest group <- current group
    return sorted largest group

An alternative way to do this is with a union find. In this case the UnionFind has a most_members property
that determines which parent has the most members. The current implementation is:

    @property
    def most_members(self):
        """
        This function will return the parent with the most members.
        """
        most_members = -1
        for parent in set(self.union_find):
            if most_members < 0:
                most_members = parent
            if self.union_find.count(parent) > self.union_find.count(most_members):
                most_members = parent
        return most_members

largest item association function parameters: associations list of list of string
    sort and flatten the incoming associations, i.e.:
        sorted_items = sorted(set([item for sublist in associations for item in sublist]))
    create a map of items to a unique ID, i.e.:
        items_to_id = {sorted_items[index]: index for index in range(len(sorted_items))}
    uf <- UnionFind(length of sorted items)
    for items in associations
        uf .union items[0] items[1]
    return list <- empty list
    most members <- uf .most_members   # Returns the ID of the parent with the most members
    for item in sorted items
        if uf .find item by ID == most members
            append item to return list
    return the sorted return list

Leet Code Longest Non-repeating String:
---------------------------------------
Given a string s, find the length of the longest substring without repeating characters.

Example 1:

Input: s = "abcabcbb"
Output: 3

Explanation: The answer is "abc", with the length of 3.

length of longest substring function parameters: string to check
    if length of string to check is 0
        return 0
    start index <- 0
    last seen <- empty dictionary
    longest <- [0,1]    # The start and end indices of the longest non-repeating string
    for string index, current character in enumerated string to check
        if current character in last seen
            start index <- maximum of start index or last seen [current character] + 1
        if longest[1] - longest[0] < string index + 1 - start index
            longest <- [start index, string index + 1]
        last seen [current character] <- string index
    return longest[1] - longest[0]

Leet Code Longest Palindromic String:
-------------------------------------
Given a string s, return the longest palindromic substring in s.

Example 1:

Input: s = "babad"
Output: "bab"

Note: "aba" is also a valid answer.

Assumptions: There are no spaces in the string, it is only characters a-z0-9 and that they are in lower case.

There are multiple ways to solve this challenge. The brute force solution has a time complexity of O(n**3). The
version that uses a left and right pointer is O(n**2). There is also the Manacher algorithm which is linear time,
i.e. O(n).

brute force function parameters: string to check
    if string to check == string to check reversed, i.e. [::-1]
        return string to check
    if length of string to check <= 2
        return string to check index 0
    bf longest palindrome <- ''
    for index in length of string to check
        for index2 in index + 1 to length of string to check
            if string to check [index:index2] == string to check [index:index2][::-1]
                if index2 - index > length of bf longest palindrome
                    bf longest palindrome <- string to check [index:index2]
    return bf longest palindrome

================
pointers version

get longest palindrome from helper function parameters: string to check, left index, right index
    loop while left index >= 0 and right index < length of the string to check
        if string to check [left index] != string to check [right index]
            exit loop, break
        left index -= 1
        right index += 1
    return left index + 1, right index

longest palindrome function parameters: string to check
    if string to check is a palindrome
        return string to check
    if the length of the string to check is <= 2
        return the first character of the string to check
    current longest <- [0,1]
    for index in range 1 to length of string to check
        odd <- call get longest palindrome from with index - 1, index + 1
        even <- call get longest palindrome from with index - 1, index
        longest <- max of odd even, i.e.:
             longest = max(odd, even, key=lambda x: x[1] - x[0])
        current longest <- max of longest and current longest, i.e.:
            current_longest = max(longest, current_longest, key=lambda x: x[1] - x[0])
    return string to check [current longest [0] : current longest [1]]

====================
Manacher's algorithm

The advantage of Manacher's algorithm is that it can find the longest palindrome in linear, i.e. O(n)
time.

manacher palindromes function parameters: string to check
    if string to check is already a palindrome
        return string to check
    if length of string to check <= 2
        return the first character of the string to check
    delimiter <- '#' - i.e. some character that is NOT in the string we are checking
    new string <- delimiter + delimiter.join(string to check) + delimiter
    new string length <- length of new string
    palindrome lengths <- [0] * new string length
    center <- 0
    right <- 0
    for index in range new string length
        mirror <- 2 * center + 1
        if index < right
            palindrome lengths [index] <- minimum of right - 1 or palindrome lengths [mirror]
        loop while index + 1 + palindrome lengths [index] < new string length and
                new string [index + (1 + palindrome lengths [index])] ==
                new string [index + (1 - palindrome lengths [index])]
            palindrome lengths [index] += 1
        if index + palindrome lengths [index] > right
            center <- index
            right <- 1 + palindrome lengths [index]
    longest <- max palindrome lengths
    center <- palindrome lengths .index(longest) // 2
    half word <- longest // 2
    start <- center - half word
    end <- center + half word
    add 0 to end if the longest % 2 == 0 else add 1
    return string to check [start:end]

Leet Code Median of Sorted Arrays:
----------------------------------
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median
of the two sorted arrays.

Follow up: The overall run time complexity should be O(log (m+n)).

Example 1:

Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000

Explanation: merged array = [1,2,3] and median is 2.

median of arrays function parameters: array one, array two
    # The time complexity for the sort of the two arrays is: O(NlogN)
    both arrays <- sorted(array one + array two)
    if length of both arrays == 1
        return both arrays [0]
    if length of both arrays % 2 == 0   # i.e. the length is an even number
        if length of both arrays == 2
            return sum of both arrays divided by 2, i.e.:
                return sum(both arrays)/2
        index = length of both arrays - 1 // 2
        return both arrays [index] + both arrays [index + 1] / 2
    return both arrays [length of both arrays // 2]     # i.e. the length is odd, return the middle value

Leet Code Minimum Difficulty Job Schedule:
------------------------------------------
You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the i-th
job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum
of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty
of a job done in that day.

Given an array of integers jobDifficulty and an integer d. The difficulty of the i-th job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.

Example 1:

Day 1: 6, 5, 4, 3, 2
Day 2: 1

Input: jobDifficulty = [6,5,4,3,2,1], d = 2
Output: 7

The approach is to set up functions inside the main function that will be called recursively. I also
use either memoization or the functools lru_cache(maxsize=None) to cache the results so that we don't
have to keep recalculating for values we've already seen.

My memoize wrapper is:

def memoize(func):
    memo = {}

    @wraps(func)
    def inner(*args):
        if (args,) not in memo:
            memo[(args,)] = func(*args)
        # print("%s returning: %s args: %s" % (func.__name__, memo[(args,)], (*args,)))
        return memo[(args,)]
    return inner

In pseudocode:
memoize
    memo <- empty dictionary
    @wraps(func)
    inner parameters: *args
        if (args,) not in memo:
            memo [(args,)] = func(*args)
        return memo[(args,)]
    return inner

minimum difficulty function parameters: list of integers for job difficulties, number of days
    if length of the list of job difficulties < number of days
        return -1   # Can't divide up fewer jobs than we have days
    if length of the list of job difficulties == number of days
        return the sum of the difficulties

    @memoize or @lru_cache
    array max function parameters: start index, end index
        return the max from job difficulties [start:end]

    @memoize of @lru_cache
    recursion function parameters: previous, day
        if day == 1
            return result from call array max with previous and length of job difficulties
        difficulty <- float('inf')
        for index in range previous + 1, length of job difficulties - day + 2
            current <- result from call to array max with previous, index +
                result from call to recursion with index, day - 1
            difficulty <- minimum of current, difficulty
        return difficulty

    res <- recursion(0, number of days)
    if res == float('inf')
        return -1
    return res

Leet Code Most Common Word:
---------------------------
Given a paragraph and a list of banned words, return the most frequent word that is not in
the list of banned words.  It is guaranteed there is at least one word that isn't banned, and
that the answer is unique.

Words in the list of banned words are given in lowercase, and free of punctuation.  Words in
the paragraph are not case sensitive.  The answer is in lowercase.

Example:

Input:

paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]

Output: "ball"

Explanation:

"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.

most common word function parameters: paragraph string, list of banned words
    table <- str.maketrans('','', string.punctuation)
    words <- default dictionary of int
    for word in lower case paragraph without punctuation and split into individual words, i.e.:
        # for word in paragraph.translate(table).lower().split()
        words [word] += 1
    for word, count in words sorted by count and reversed so highest values come first, i.e.:
        # reversed(sorted(words.items(), key=lambda item: item[1]))
        if word in banned:
            skip this word, i.e. continue
        return word

Leet Code Number of Islands:
----------------------------
Given an m x n 2d grid map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or
vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]

Output: 1

The idea is: Once you find an island, convert all of the land to water so that you don't accidentally count
it again as an island.

CHECK DIRECTIONS <- list [
    (1, 0),             # Up
    (-1, 0),            # Down
    (0, 1),             # Right
    (0, -1),            # Left
]

replace with water iterative helper function parameters: grid, rows, cols, row, col
    queue <- deque()
    append row, col to queue
    grid [row][col] = '0'       # i.e. replace land with water
    loop while we have items in the queue
        row, col <- pop from queue
        for direction in CHECK DIRECTIONS
            check row <- row + direction[0]
            check col <- col + direction[1]
            if -1 < check row < rows and
                            -1 < check col < cols and
                            grid[check row][check col] == '1'
                append to queue check row, check col
                grid[check row][check col] = '0'        # i.e. replace land with water

number of islands iterative function parameters: grid a list of lists of string
    if there is no grid
        return 0
    number of islands <- 0
    rows <- length of grid
    cols <- length of grid [0]
    for row index in range of number of rows
        for col index in range of number of cols
            if grid[row][col] == '1':
                number of islands += 1
                call replace with water iterative with grid, rows, cols, row, col
    return number of islands

This can also be done recursively:

replace with water recursive helper function parameters: grid, row, col
    if row < 0 or col < 0 or row >= length of grid or col >= length of grid[0] or grid[row][col] != '1'
        return
    grid[row][col] = '0'
    for direction in CHECK DIRECTIONS
        call replace with water recursive with grid, row + direction[0], col + direction[1]

number of islands recursive function parameters: grid of list of lists of string
    if there is no grid
        return 0
    number of islands = 0
    for row in range length of grid
        for col in range length of grid[0]
            if grid[row][col] == '1'
                number of islands += 1
                call replace with water recursive with grid, row, col
    return number of islands

Leet Code Prime Air Route:
--------------------------
Amazon Prime Air is developing a system that divides shipping routes using
flight optimization routing systems to a cluster of aircraft that can
fulfill these routes. Each shipping route is identified by a unique integer
identifier, requires a fixed non-zero amount of travel distance between
airports, and is defined to be either a forward shipping route or a return
shipping rout. Identifiers are guaranteed to be unique within their own
route type, but not across route types.

Each aircraft should be assigned two shipping routes at once: one forward
route and one return route. Due to the complex scheduling of flight plans,
all aircraft have a fixed maximum operating travel distance, and cannot
be scheduled to fly a shipping route that requires more travel distance
than the prescribed maximum opeerating travel distance. The goal of the
system is to optimize the total operating travel distance of a given aircraft.
A forward/return shipping rout pair is considered to be "optimal" if there
does not exist another pair that has a higher operating travel travel distance
than this pair, and also has a total less than or equal to the maximum
operating travel distance of the aircraft.

For example, if the aircraft has a maximum operating travel distance of 3,000
miles, a forward/return shipping route pair using a total of 2,900 miles would
be optimal if there does not exist a pair that uses a total operating travel
distance of 3,000 miles, but would not be considered optimal if such a
pair did exist.

Your task is to write an algorithm to optimize the sets of forward/return
shipping route pairs that allow the aircraft to be optimally utilized, given
a list of forward shipping routes and a list of return shipping routes.

Input:

The input to the function/method consists of three arguments:

- maxTravelDist, an integer representing the maximum operating travel distance
  of a given aircraft;
- forwardRouteList, a list of pairs of integers where the first integer
  represents the unique identifier of a forward shipping route and the second
  integer represents the amount of travel distance required by this shipping
  route;
- returnRouteList, a list of pairs of integers where the first integer represents
  the unique identifier of a return shipping route and the second integer
  represents the amount of travel distance required by this shipping route.

Output:

Return a list of pairs of integers representing the pairs of IDs of forward and
return shipping routes that optimally utilize the given aircraft. If no route
is possible, return a list with an empty pair.

Examples:

Input:
    maxTravelDist = 7000
    forwardRouteList = [[1,2000],[2,4000],[3,6000]]
    returnRouteList = [[1,2000]]

Output:
    [[2,1]]

Explanation:

There are only three combinations: [1,1], [2,1], and [3,1], which have a total of
4,000, 6,000 and 8,000 miles respectively. Since 6,000 is the largest use that does
not exceed 7,000 [2,1] is the only optimal pair.

optimal flight path function parameters: maximum travel distance, forward route list, return route list
    if no forward route list or no return route list
        return empty list
    if maximum travel distance <= 0
        return empty list
    best distance <- empty list     # Format: index 0 is the distance index 1 list of to/from routes
    loop through forward route list and return route list creating a list with distance and forward
        route number and return route number, i.e.:
            for distance, to from route in [[frl[1] + rrl[1], [frl[0], rrl[0]]]
                                            for frl in forward route list
                                            for rrl in return rout list]
        if distance <= maximum travel distance
            if there is a best distance
                if distance == best distance[0]
                    append routes to best distance[1]
                if distance > best distance[0]
                    best distance <- [distance, [to from route]]
            else
                best distance <- [distance, [to from route]]
    return best distance[1]

Leet Code Reorder Log Files:
----------------------------
You have an array of logs.  Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric identifier.  Then, either:

Each word after the identifier will consist only of lowercase letters, or;
Each word after the identifier will consist only of digit_logs.
We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has
at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered
lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should
be put in their original order.

Return the final order of the logs.



Example 1:

Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]

reorder log files function parameters: list of logs
    digit logs <- empty list
    letter logs <- empty list
    loop through logs
        log ID, log data <- log entry split maxsplit=1
        if log data .replace ' ', '' is_digit()
            append log entry to digit logs
        else
            append log entry to letter logs
    return sorted letter logs based on the data followed by the ID + digit logs, i.e.:
        return sorted(letter_logs, key=lambda x: (x.split()[1:], x.split()[0])) + digit_logs

Leet Code Song Pairs Divisible by 60:
-------------------------------------
You are given a list of songs where the ith song has a duration of time[i] seconds.

Return the number of pairs of songs for which their total duration in seconds is divisible by 60.
Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.

Example 1:

Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60

Approach 1: Brute Force
One of the most straightforward approaches would be iterating through the entire array using a nested loop
to examine that, for each element a in time, whether there is another element b such that (a + b) % 60 == 0.
Note that this approach might be too brutal to pass an interview.

brute force number of pairs divisible by 60 function parameters: list of times for songs
    ret <- 0
    n <- length of list of times of songs
    for index in range n
        for index2 for range index + 1, n
            increment ret if (time[index] + time[index2]) % 60 == 0, i.e.:
                ret += (time[i] + time[j]) % 60 == 0
    return ret

Approach 2: Hashmap

Intuition

Let's dive deep into the condition (time[i] + time[j]) % 60 == 0 to examine the relation between
time[i] and time[j]. Assuming that a and b are two elements in the input array time, we have:

(a + b) % 60 == 0
((a % 60) + (b % 60)) % 60 == 0

Therefore, either:
a % 60 == 0,
            or (a % 60) + (b % 60) == 60
b % 60 == 0,

Hence, all we need would be finding the pairs of elements in time so they meet these conditions.

Algorithm

We would iterate through the input array time and for each element a, we want to know the number
of elements b such that:

1. b % 60 = 0, if a % 60=0
2. b % 60 = 60 - a % 60, if a % 60 != 0

We can use Approach 1 to implement this logic by repeatedly examining the rest of time again and again
for each element a. However, we are able to improve the time complexity by consuming more space - we
can store the frequencies of the remainder a % 60, so that we can find the number of the complements
in O(1) time.

number of pairs divisible by 60 function parameters: list of times for songs
    remainders <- default dictionary of int
    ret <- 0
    for time in list of times for songs
        if time % 60 == 0
            ret += remainders[0]        # i.e. we add the number of songs that are divisible by 60
        else
            ret += remainders[60 - time % 60]
        remainders[time % 60] += 1
    return ret

Leet Code Turnstile:
--------------------
A university has exactly one turnstile. It can be used either as an exit or an entrance. Unfortunately,
sometimes many people want to pass through the turnstile and their directions can be different. The
i-th person comes to the turnstile at time[i] and wants to either exit the university if direction[i] == 1
or enter the university if direction[i] == 0. People form two queues, one to exit and one to enter.
They are ordered by the time when they came to the turnstile and, if the times are equal, by their indices.

If some person wants to enter the university and another person wants to leave the university at the
same moment there are three cases:

-   If in the previous second the turnstile was not used (maybe it was used before, but not at the
    previous second), then the person who wants to leave goes first.
-   If in the previous second the turnstile was used as an exit, then the person who wants to leave goes first.
-   If in the previous second the turnstile was used as an entrance, then the person who wants to
    enter goes first.

Passing through the turnstile takes 1 second.

For each person find the time when they will pass through the turnstile.

Set up some variables

EXITING = 1
ENTERING = 0
ENETERING_EXITING = ["Entering", "Exiting"]

# The elements of the queue will be:
TIME = 0
DIRECTION = 1
INDEX = 2

I need to track the index of the person who is going through the turnstile based on when that
person entered the queue to ensure the times are update correctly.

NOTE: The "person" below consists of the time, direction and index for this "person"

let person go helper function parameters: person1, person2, the queue, return times
    return times [person1[INDEX]] <- person1[TIME]
    person2[TIME] += 1
    insert person2 onto head of queue

NOTE: direction is either 0 for entering or 1 for exiting

turnstile function parameters: times list of ints, directions list of ints
    create the queue as a deque using the following:
        deque([[times[i],directions[i], i] for i in range(len(times))])
    return times <- [-1] * length of times
    last direction <- 1         # We prefer exiting over entering
    last used time <- -1
    loop while we have a queue
        current <- pop from queue
        if current[TIME] <= last used
            current[TIME] <- last used + 1
        # The following happens when two people arrived at the same time
        if there is a queue and current[TIME] == queue[0][TIME]
            next person <- pop from queue
            # if the turnstile has not been used or not used for at least 1 second
            # then prefer the person exiting over the person entering
            if last used < 0 or current[TIME] - last used > 1
                if current[DIRECTION] == EXITING
                    call let person go with: current, next person, the queue, the return times
                    last used <- current[TIME]
                    last direction <- EXITING
                else if next person[DIRECTION] == EXITING
                    call let person go with: next person, current, the queue, the return times
                    last used <- next person[TIME]
                    last direction <- EXITING
                else
                    # No one in the queue is exiting, just let current go
                    call let person go with: current, next person, the queue, the return times
                    last used <- current[TIME]
                    last direction <- current[DIRECTION]
            # OK, the turnstile has been used recently, prefer the current direction
            else
                # Unlike above, the direction for the first two cases is not changing
                # so it will not need to be updated
                if current[DIRECTION] == last direction
                    call let person go with: current, next person, the queue, the return times
                    last used <- current[TIME]
                else if next person[DIRECTION] == last direction
                    call let person go with: next person, current, the queue, the return times
                    last used <- next person[TIME]
                else
                    # May be changing directions here, so update last direction
                    call let person go with: current, next person, the queue, the return times
                    last used <- current[TIME]
                    last direction <- current[DIRECTION]
        # This is the else for if times for current and next person are the same
        # We are here because the times for current and next person are different
        else
            if current[TIME] == last used
                return times[current[INDEX]] <- current[TIME] + 1
            else
                return times[current[INDEX]] <- current[TIME]
            last direction <- current[DIRECTION]
            last used <- current[TIME]
    return return times

Leet Code Two Sum:
------------------
Given an array of integers nums and an integer target, return indices of the two numbers such
that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same
element twice.

You can return the answer in any order.

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Output: Because nums[0] + nums[1] == 9, we return [0, 1].

The time complexity for the following should be O(n) since we will go through the input at most once.
The space is also O(n) since we create a dictionary of each value.

two sums function parameters: nums list of ints, target
    remainders <- empty dictionary
    for index, number in enumerate nums
        if target - number in remainders
            return [remainders[target - number], index]
        remainders[number] <- index
    return []

Leet Code Unique Substring of Size k:
-------------------------------------
Given a string s and an int k, return all unique substrings of s of size k with k distinct characters.

Example 1:

Input: s = "abcabc", k = 3
Output: ["abc", "bca", "cab"]

Starting with the incoming string and an integer value that will determine the size of the strings to
return. We will need to loop through the string, check if we've seen this character before. If we have
we will need to update the start of substring value to just pass the last time we saw this character.
We need to be sure that we don't move the start backwards, so only move it past the last time, plus 1,
that we saw a character if it is less or equal to the last time we saw that character.

If we have found a substring of the correct length, then add it to the result and move the start
pointer over 1.

generate substrings function parameters: string, size k
    results <- empty set
    seen <- empty dictionary
    start <- 0
    string length <- length of string
    for index in range string length
        if string[index] in seen:
            if start <= seen[string[index]]
                start <- seen[string[index]] + 1
        seen[string[index]] <- index
        if (index + 1) - start == k
            results.add(string[start:index + 1]
            start += 1
    return list of results

Reviews and Keywords:
---------------------
Given a list of reviews, a list of keywords and an integer k. Find the most popular
k keywords in order of most to least frequently mentioned. The comparison of strings
is case-insensitive.

Multiple occurrences of a keyword in a review should be considered as a single mention.
If keywords are mentioned an equal number of times in reviews, sort alphabetically.

get keywords function parameters: number of keywords, keywords, reviews
    keywords counts <- default dictionary of int
    loop through reviews
        loop through keywords
            if keyword.lower() in review.lower()
                keywords count[keyword] += 1
    counts <- list of count and keyword sorted and reversed, i.e.
        counts = list(reversed(sorted(sorted([(v, k) for k,v in keyword_counts.items()],key=lambda v: v[1]))))
    if length of counts == number of keywords
        return [x[1] for x in counts]   # i.e. return the keyword which is the second element
    return counts <- empty list
    for index in range length of counts - 1
        if counts[index][0] > counts[index + 1][0]
            append to return counts counts[index][1]
        else if counts[index][0] == counts[index + 1][0]
            extend the return counts by sorted list of keywords, i.e.:
                return_counts.extend([x[1] for x in sorted([counts[index],counts[index+1]],key=lambda x: x[1])])
        if length of the return counts >= number of keywords
            exit the loop
    return return counts [:number of keywords]

Score of Parentheses:
---------------------
Given a balanced parentheses string S, compute the score of the string based on the following rule:

() has score 1
AB has score A + B, where A and B are balanced parentheses strings.
(A) has score 2 * A, where A is a balanced parentheses string.

Example 1:

Input: "()"
Output: 1

score of parentheses recursive parameters: string to check
    inner function count parameters: i, j
        ans = bal = 0
        for k in range i, j
            bal += 1 if string[k] == '('' else -1
            if bal == 0             # have balanced parentheses
                # if k - i == 1 have balanced parentheses one after the other
                if k - i == 1
                    ans += 1
                else
                    # The matching parens are not next to each other, check next substring
                    ans += 2 * result from call to count with i + 1, k
                i = k + 1
        return ans
    return result from call to count with 0, length of incoming string

score of parentheses iterative parameters: string to check
    ans = k = 0
    for i in range length of string
        k += 1 if string[i] == '(' else -1
        if string[i - 1:i + 1] == '()'
            ans += 2 ** k
    return ans

Unix Domain Socket Client:
--------------------------
This challenge tests your understanding of Sockets and Multi-Threaded programming.

Your task is to write a UNIX Domain Socket(UDS) server which can accept connection from 'N' clients.
Each client will send text data over the socket. Read the data and send it back to the client. The
server should be Multi-Threaded and should service all clients in parallel.

To support Multi-Threading you can use the POSIX thread library (C,C++) or the default threading library
for other languages.

Communication Protocol

Read data from client and send the response back.
String "END" marks end of communication from a client. Send response "END" and disconnect the client.

Example request 1:

Client 1:
Hello World
END
Example response 1:

Client 1:
Hello World
Example request 2:

Client 2:
This is line 1
This is line 2
END
Example response 2:

Client 2:
This is line 1
This is line 2

The Unix Domain Socket, UDS, test is: the client will send a message to the server, the
server will simply send the message back.

The client code is:

message <- '...'
sock <- socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
server address <- "./.uds_socket"
try:
    sock.connect(server address)
except socket.error as msg
    print received socket error: msg
    sys.exit(-1)
try
    sock.send_all(message)
    amount received <- 0
    amount expected <- length of message
    loop while amount received < amount expected
        data <- sock.recv(16)
        amount received += length of data
finally
    sock.sendall(b'quit')
    time.sleep(2)
    sock.close()

The server code is:
server address <- './.uds_socket'
try
    os.unlink(server address)
except OSError
    if os.path.exists(server address)
    raise
loop <- get event loop from asyncio
server <- socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
bind server to server address
server listen
set blocking on server to False
async def handle client parameters: client
    request = None
    loop while the request is != 'quit']
        request <- await loop sock.recv(client, 255) decode ('utf-8')
        response <- string of request
        try
            await loop.sock_sendall(client, response.encode('utf-8'))
        except broken pipe
            break
    close the client
async def run server parameters: None
    while True
        client, _ <- await loop.sock_accept on server
        loop.create_task(handle_client(client))

main function
    run until complete the event loop with run_server()

Algo Expert Knuth-Morris-Pratt String Search Algorithm:
-------------------------------------------------------
The general idea behind this algorithm is that you create a "pattern", also called the "failure
function", of the substring for which you will be searching the has indices for any prefixes/suffixes
that match in the substring. This allows you not necessarily have to go back to the beginning of the
substring each time you have a mismatch with the string. The general format is:

  0    1    2    3    4    5    6    7    8    9   10   11   12   13
  f    a    w    f    a    w    f    a    w    f    a    w    f    a
 -1   -1   -1    0    1    2    3    4    5    6    7    8    9   10

 In the pattern above we start at index 0, the letter 'f', since we haven't found any matches for this
 'f' we leave the value in the pattern at -1. This continues until we find the second 'f'. We store the
 index of the previous 'f', i.e. 0, then we find a match for 'a' which is at index 1, then the 'w' at
 index 2. Then we find another 'f' so we store the index of the most recent other 'f' we've found which
 is at index 3. Since that pattern continues to repeat we end up storing: a=4, w=5, f=6, a=7, w=8, f=9
 and finally a=10.

build pattern helper function parameters: search substring
    pattern <- [-1] * length of substring
    i <- 1
    j <- 0
    loop while i < length of the substring
        if substring[i] == substring[j]
            pattern[i] = j
            j += 1
            i += 1
        else if j > 0                   # We must have found a match somewhere
            j <- pattern[j - 1] + 1
        else
            i += 1

Using the following substring we compute the pattern, aka "failure function" as:

  0    1    2    3    4    5    6    7
  a    e    f    c    d    a    e    d
 -1   -1   -1   -1   -1    0    1   -1

 Assume the following string:

  0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16
  a    e    f    o    a    e    f    c    d    a    e    f    c    d    a    e    d

does match helper function parameters: string, substring, pattern
    i <- 0
    j <- 0
    loop while i + length of the substring - j <= length of the string, i.e.:
        # while i + len(substring_in) - j <= len(string_in)
        if string[i] == substring[j]
            if j == length of the substring - 1     # We've matched everything and reached the end of the substring
                return True
            i += 1
            j += 1
        else if j > 0
            j <- pattern[j - 1] + 1
        else
            i += 1
    return False        # If we've gotten this far without hitting the above condition where we were matching
                        # the substring to the string and reached the end of the substring, then there is no
                        # match in the string for the substring.

knuth morris pratt function parameters: string, substring
    pattern <- result from call to build pattern with substring
    return result from call to does match with: string, substring, pattern

